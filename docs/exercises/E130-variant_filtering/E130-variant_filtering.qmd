---
engine: knitr
---

```{bash }
#| label: E130-data-setup
#| echo: false
#| eval: true
DATADIR=$(realpath ../../data/data/ooa-outgroups)
for f in ${DATADIR}/[CY]*.chr21.bam*; do
	ln -f -s $f ./$(basename $f)
done
ln -f -s $DATADIR/ooa.chr22.ref.fa .
```


# Variant filtering {#sec-E130-variant_filtering}

Regardless of how a raw variant call set has been produced, the calls
will be of varying quality for a number of reasons. For high-coverage
sequencing, the two most common are incompleteness of the reference
sequence and misaligmnents in repetitive regions
[@li_BetterUnderstandingArtifacts_2014]. Low-coverage sequencing comes
with its own biases, such as



::: {.callout-warning}

## FIXME

Discuss different types of relevant filters, e.g.

- filtering on read depth, both high to eliminate collapsed repeats,
  and low for mappability issues. This is particularly important for
  incomplete assemblies


:::

### Intended learning outcomes

- create per sample, per population, and total depth of coverage profiles
- generate mask files for downstream processing


### Tools

- [mosdepth](https://github.com/brentp/mosdepth)  [@pedersen_MosdepthQuickCoverage_2018]
- [samtools](https://github.com/samtools/samtools) [@danecek_TwelveYearsSAMtools_2021]
- [csvtk](https://bioinf.shenwei.me/csvtk/)
- [bedtools](https://bedtools.readthedocs.io/en/latest/index.html) [@quinlan_BEDToolsFlexibleSuite_2010]

### Input data

We will be working with the [Out of
Africa](../data.qmd#sec-data-simulated-ooa) dataset, consisting of 10
samples from the CEU, CHB, and YRI populations. The input consists of
10 bam files:

```{bash }
#| label: e130-input-data
#| echo: true
#| eval: true
ls -lLh *.bam
```

Each population consists of a collection - or set -of samples, and we
will sometimes use the term `sample set` to refer to such a
collection. For instance, the population or sample set `CHB` consists
of the set `CHB-1`, `CHB-2` and `CHB-3`.

## Coverage analyses

Mapped reads

Sequencing coverage is typically not uniformly distributed over
Reasons may vary but include uneven mapping coverage due to repeat
regions, low coverage due to mis-assemblies, or coverage biases
generated in the sequencing process. Importantly, both variable and
monomorphic sites must be treated identically in the filtering process
to avoid selection biases.

In this part, we will use `mosdepth` and `bedtools` to quickly
generate depth of coverage profiles of mapped data. `mosdepth` is an
ultra-fast command line tool for calculating coverage from a bam file.
By default, it generates a summary of the global distribution, and
per-base coverage in `bed.gz` format. We will be using the per-base
coverage for filtering.

Alternatively, `mosdepth` can also output results in a highly
compressed format `d4`, which has been developed to handle the ever
increasing size of resequencing projects. Files in d4 format can be
processed with the [d4-tools](https://github.com/38/d4-format) tool
[@hou_BalancingEfficientAnalysis_2021]. For instance, `d4tools view`
will display the coverage in `bed` format. We mention this in passing
as it may be relevant when working with large genomes or sample sizes,
but given the size of our sample data, we will be using `bedtools`
from now on.

### Per sample coverage

We start by calculating per-sample coverages with `mosdepth`. For
downstream purposes, we need to save the size of the chromosomes we're
looking at:

```{bash }
#| label: samtools-view-header
#| echo: true
#| eval: true
samtools view CEU-1.ooa.chr21.bam -H | grep SQ | awk '{OFS="\t";print $2, $3}' | sed -e "s/[SNL:]//g" > genome.txt
```

The syntax to generate coverage information for a bam file is
`mosdepth <prefix> <input file>`. Here, we add the `-Q` option to
exclude reads with a mapping quality less than 20:

```{bash }
#| label: mosdepth-one-sample
#| echo: true
#| eval: true
mosdepth -Q 20 CEU-1 CEU-1.ooa.chr21.bam
```

The per-base coverage output file will be named
`CEU-1.per-base.bed.gz` and can be viewed with `bgzip`:

```{bash }
#| label: bgzip-view-sample
#| echo: true
#| eval: true
bgzip -c -d CEU-1.per-base.bed.gz | head -n 5
```

To get an idea of what the coverage looks like over the chromsome, we
can use `bedtools` and `cvstk` in a one-liner to generate a simple
coverage plot (@fig-plot-coverage)[^bedtools-oneliner].

```{bash }
#| label: bash-plot-coverage
#| echo: true
#| eval: true
#| fig-show: asis
#| fig-cap: Coverage for sample CEU-1 in 5kb windows. Experiment changing the window size (`-w`) parameter to change smoothing.
bedtools intersect -a <(bedtools makewindows -g genome.txt -w 5000) \
		 -b CEU-1.per-base.bed.gz -wa -wb | \
	bedtools groupby -i - -g 1,2,3 -c 7 -o mean | \
	csvtk plot -t line -x 2 -y 4 --point-size 0.01 --xlab Position \
		  --ylab Coverage --width 9.0 --height 3.5 > fig-plot-coverage.png
```

::: {#fig-plot-coverage attr-output='.details summary="Output"'}

![](fig-plot-coverage.png)

Coverage for sample CEU-1 in 5kb windows. Experiment changing the
window size (`-w`) parameter to change smoothing.

:::

Apparently there are some high-coverage regions that could be
associated with, e.g., collapsed repeat regions in the assembly. Let's
compile coverage results for all samples, using bash string
manipulation to generate file prefix [^bash-string-manipulation]:

```{bash }
#| label: mosdepth-compile-coverage-data
#| echo: true
#| eval: true
for f in *.bam; do
	prefix=${f%.ooa.chr21.bam}
	mosdepth -Q 20 $prefix $f
	echo -e -n "$prefix\t"
	cat $prefix.mosdepth.summary.txt | grep total
done
```

### Sample set coverages

We can combine coverage intervals with `bedtools unionbedg`. We
collect the bed file names and generate matching sample names to pass
as arguments to option `-names`. Also, we include positions with no
coverage (`-empty`) which requires the use of a genome file (option
`-g`). The bed output is piped to `bgzip` which compresses the output,
before finally indexing with `tabix`:

```{bash }
#| label: bedtools-unionbedg-all
#| echo: true
#| eval: true
BEDGZ=$(for f in *.per-base.bed.gz; do echo "$f "; done)
SAMPLES=$(for f in $BEDGZ; do echo -e -n "${f%.per-base.bed.gz} "; done)
bedtools unionbedg -header -names $SAMPLES -g genome.txt -empty -i $BEDGZ | bgzip > ALL.bg.gz
tabix -f -p bed -S 1 ALL.bed.gz
```

We also need to combine coverages per populations CEU, CHB, and YRI.
Using the previous command as a template, try to generate per
population coverage files.

```{bash }
#| label: bedtools-unionbedg-per-population
#| echo: true
#| eval: true
#| code-fold: true
for pop in CEU CHB YRI; do
	BEDGZ=$(for f in ${pop}*.per-base.bed.gz; do echo "$f "; done)
	SAMPLES=$(for f in $BEDGZ; do echo -e -n "${f%.per-base.bed.gz} "; done)
	bedtools unionbedg -header -names $SAMPLES -g genome.txt -empty -i $BEDGZ | bgzip > $pop.bed.gz
	tabix -f -p bed -S 1 $pop.bed.gz
done
```

### Total coverage

Since we eventually want to filter on total coverage, we sum per
sample coverages for each sample set with `awk`:
```{bash }
#| label: awk-sum-ALL-coverage
#| echo: true
#| eval: true
bgzip -c -d ALL.bed.gz | awk -v FS="\t" -v OFS="\t" 'NR > 1 {sum=0; for (i=4; i<=NF; i++) sum+=$i; print $1, $2, $3, sum}' | bgzip > ALL.sum.bed.gz
tabix -f -p bed ALL.sum.bed.gz
```

For illustration, we plot the total coverage:
```{bash }
#| label: total-coverage
#| echo: true
#| eval: true
#| fig-show: asis
#| fig-cap: Coverage for ALL samples in 5kb windows. Experiment changing the window size (`-w`) parameter to change smoothing.
bgzip -c -d |
bedtools intersect -a <(bedtools makewindows -g genome.txt -w 5000) \
		 -b ALL.sum.bed.gz -wa -wb | \
	bedtools groupby -i - -g 1,2,3 -c 7 -o mean | \
	csvtk plot -t line -x 2 -y 4 --point-size 0.01 --xlab Position \
		  --ylab Coverage --width 9.0 --height 3.5 > fig-plot-total-coverage.png
```

::: {.callout-note}

#### Exercise

Generate coverage sums for sample sets CEU, CHB, and YRI.

```{bash }
#| label: awk-sum-sample-set-coverage
#| echo: true
#| eval: true
#| code-fold: true
for pop in CEU CHB YRI; do
	bgzip -c -d $pop.bed.gz | awk -v FS="\t" -v OFS="\t" 'NR > 1 {sum=0; for (i=4; i<=NF; i++) sum+=$i; print $1, $2, $3, sum}' | bgzip > $pop.sum.bed.gz
	tabix -f -p bed $pop.sum.bed.gz
done
```


:::


Now we have combined total per sample coverage for ALL samples, and
for sample sets CEU, CHB, and YRI. The upcoming task will be to
generate sequence masks from the total coverage and minimum number of
individuals with coverage greater than zero.


### Sequence masks

[^bedtools-oneliner]: The one-liner combines the results of several
    commands in a pipe stream. Also, [Bash
    redirections](https://www.gnu.org/software/bash/manual/html_node/Redirections.html)
    are used to gather the results from the output of `bedtools
    makewindows` to `bedtools intersect`. The intersection commands
    collects coverage data in 5kb windows that are then summarized by
    `bedtools groupby`.

[^bash-string-manipulation]: The `%` operator deletes the shortest
match of `$substring` from back of `$string`: `${string%substring}`.
See [Bash string
manipulation](https://tldp.org/LDP/abs/html/string-manipulation.html)
for more information.
